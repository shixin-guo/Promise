"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type GlobalData {
  id: ID!
  listingPrice: BigInt!
  listingPriceUpdateAt: BigInt!
}

input GlobalData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  listingPrice: BigInt
  listingPriceUpdateAt: BigInt
  listingPriceUpdateAt_gt: BigInt
  listingPriceUpdateAt_gte: BigInt
  listingPriceUpdateAt_in: [BigInt!]
  listingPriceUpdateAt_lt: BigInt
  listingPriceUpdateAt_lte: BigInt
  listingPriceUpdateAt_not: BigInt
  listingPriceUpdateAt_not_in: [BigInt!]
  listingPrice_gt: BigInt
  listingPrice_gte: BigInt
  listingPrice_in: [BigInt!]
  listingPrice_lt: BigInt
  listingPrice_lte: BigInt
  listingPrice_not: BigInt
  listingPrice_not_in: [BigInt!]
}

enum GlobalData_orderBy {
  id
  listingPrice
  listingPriceUpdateAt
}

type NFT {
  createdAt: BigInt!
  creator: User!
  fileUrl: String!
  id: ID!
  owner: User!
  price: BigInt!
  sold: Boolean!
  specs: String
  updatedAt: BigInt
}

input NFT_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  createdAt: BigInt
  createdAt_gt: BigInt
  createdAt_gte: BigInt
  createdAt_in: [BigInt!]
  createdAt_lt: BigInt
  createdAt_lte: BigInt
  createdAt_not: BigInt
  createdAt_not_in: [BigInt!]
  creator: String
  creator_: User_filter
  creator_contains: String
  creator_contains_nocase: String
  creator_ends_with: String
  creator_ends_with_nocase: String
  creator_gt: String
  creator_gte: String
  creator_in: [String!]
  creator_lt: String
  creator_lte: String
  creator_not: String
  creator_not_contains: String
  creator_not_contains_nocase: String
  creator_not_ends_with: String
  creator_not_ends_with_nocase: String
  creator_not_in: [String!]
  creator_not_starts_with: String
  creator_not_starts_with_nocase: String
  creator_starts_with: String
  creator_starts_with_nocase: String
  fileUrl: String
  fileUrl_contains: String
  fileUrl_contains_nocase: String
  fileUrl_ends_with: String
  fileUrl_ends_with_nocase: String
  fileUrl_gt: String
  fileUrl_gte: String
  fileUrl_in: [String!]
  fileUrl_lt: String
  fileUrl_lte: String
  fileUrl_not: String
  fileUrl_not_contains: String
  fileUrl_not_contains_nocase: String
  fileUrl_not_ends_with: String
  fileUrl_not_ends_with_nocase: String
  fileUrl_not_in: [String!]
  fileUrl_not_starts_with: String
  fileUrl_not_starts_with_nocase: String
  fileUrl_starts_with: String
  fileUrl_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  owner: String
  owner_: User_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  price: BigInt
  price_gt: BigInt
  price_gte: BigInt
  price_in: [BigInt!]
  price_lt: BigInt
  price_lte: BigInt
  price_not: BigInt
  price_not_in: [BigInt!]
  sold: Boolean
  sold_in: [Boolean!]
  sold_not: Boolean
  sold_not_in: [Boolean!]
  specs: String
  specs_contains: String
  specs_contains_nocase: String
  specs_ends_with: String
  specs_ends_with_nocase: String
  specs_gt: String
  specs_gte: String
  specs_in: [String!]
  specs_lt: String
  specs_lte: String
  specs_not: String
  specs_not_contains: String
  specs_not_contains_nocase: String
  specs_not_ends_with: String
  specs_not_ends_with_nocase: String
  specs_not_in: [String!]
  specs_not_starts_with: String
  specs_not_starts_with_nocase: String
  specs_starts_with: String
  specs_starts_with_nocase: String
  updatedAt: BigInt
  updatedAt_gt: BigInt
  updatedAt_gte: BigInt
  updatedAt_in: [BigInt!]
  updatedAt_lt: BigInt
  updatedAt_lte: BigInt
  updatedAt_not: BigInt
  updatedAt_not_in: [BigInt!]
}

enum NFT_orderBy {
  createdAt
  creator
  fileUrl
  id
  owner
  price
  sold
  specs
  updatedAt
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  globalData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalData
  globalDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalData_filter
  ): [GlobalData!]!
  nft(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NFT
  nfts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NFT_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NFT_filter
  ): [NFT!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  globalData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalData
  globalDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalData_filter
  ): [GlobalData!]!
  nft(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NFT
  nfts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NFT_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NFT_filter
  ): [NFT!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type User {
  createdToken(
    first: Int = 100
    orderBy: NFT_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: NFT_filter
  ): [NFT!]
  firstJoinTime: BigInt!
  id: ID!
  lastActivityTime: BigInt!
  ownedToken(
    first: Int = 100
    orderBy: NFT_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: NFT_filter
  ): [NFT!]
}

input User_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  createdToken_: NFT_filter
  firstJoinTime: BigInt
  firstJoinTime_gt: BigInt
  firstJoinTime_gte: BigInt
  firstJoinTime_in: [BigInt!]
  firstJoinTime_lt: BigInt
  firstJoinTime_lte: BigInt
  firstJoinTime_not: BigInt
  firstJoinTime_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastActivityTime: BigInt
  lastActivityTime_gt: BigInt
  lastActivityTime_gte: BigInt
  lastActivityTime_in: [BigInt!]
  lastActivityTime_lt: BigInt
  lastActivityTime_lte: BigInt
  lastActivityTime_not: BigInt
  lastActivityTime_not_in: [BigInt!]
  ownedToken_: NFT_filter
}

enum User_orderBy {
  createdToken
  firstJoinTime
  id
  lastActivityTime
  ownedToken
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
